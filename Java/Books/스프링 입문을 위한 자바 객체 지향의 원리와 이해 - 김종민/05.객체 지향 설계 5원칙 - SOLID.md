# 5장 객체 지향 설계 5원칙 - SOLID
## SOLID란 
객체 지향 프로그램을 잘 설계하기 위한 5원칙이다. 
- SRP(Single Responsibility Principle): 단일 책임 원칙
- OCP(Open Closed Principle): 개방 폐쇄 원칙
- LSP(Liskov Substitution Principle): 리스코프 치환 원칙
- ISP(Interface Segregation Principle): 인터페이스 분리 원칙
- DIP(Dependency Inversion Principle): 의존 역전 원칙

<br>

## SRP - 단일 책임 원칙
"어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다" - 로버트 C.마틴

<br>

### - 속성이 SRP를 지키지 않은 경우
```java
class 사람 {
    String 군번;
    ...
}

...

사람 로미오 = new 사람();
사람 줄리엣 = new 사람();

줄리엣.군번 = "`1573042009";

```

### - 메서드가 단일 책임 원칙을 지키지 않은 경우
```java
class 강아지 {
    final static Boolean 수컷 = true;
    final static Boolean 암컷 = false;
    Boolean 성별;

    void 소변보다() {
        if(this.성별 == 수컷) {
            // 한쪽 다리를 들고 소변을 본다.
        } else {
            // 뒷다리 두 개를 굽혀 앉은 자세로 소변을 본다.
        }
    }
}

``` 
강아지 클래스의 소변보다() 메서드가 수컷 강아지의 행위와 암컷 강아지의 행위를 모두 구현하려고 하기에 단일 책임(행위) 원칙을 위배하고 있는 것이다.

<br>

### - 단일 책임 원칙을 적용해 개선한 코드
```java
abstract class 강아지 {

    abstract void 소변보다()
}

class 수컷강아지 extends 강아지 {

    void 소변보다() {
        // 한쪽 다리를 들고 소변을 본다.
    }
}

class 암컷강아지 extends 강아지 {

    void 소변보다() {
        //뒷다리 두 개로 앉은 자세로 소변을 본다.
    }
}

```
***정리**
<br>
단일 책임 원칙과 객체 지향 4대 특성은 어떻게 결부돼 있을까? 캡상추다를 다시 상기해 보면 단일 책임 원칙과 가장 관계가 깊은 것은 바로 모델링 과정을 담당하는 추상화다. 애플리케이션의 경계를 정하고 추상화를 통해 클래스들을 선별하고 속성과 메서드를 설계할 때 반드시 단일 책임 원칙을 고려하는 습관을 들이자.

<br><br>

## OCP - 개방 폐쇄 원칙
"소프트웨어 엔티티(클래스, 모듈, 함수 등)는 확장에 대해서는 열려 있어야 하지만 변경에 대해서는 닫혀 있어야 한다." - 로버트 C.마틴
<br>
좀 더 쉽게 말하면, "자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다."

<br>

설명이 궁금하면 책 참고. 그림으로 쉽게 설명되어 있음.

<br><br>

## LSP - 리스코프 치환 원칙
"서브 타입은 언제나 자신의 기반 타입(base type)으로 교체할 수 있어야 한다." - 로버트 C.마틴

<br>

객체 지향에서의 상속은 조직도나 계층도가 아닌 분류도가 돼야 한다.
- 하위 클래스 is a kind of 상위 클래스 - 하위 분류는 상위 분류의 한 종류다.
- 구현 클래스 is able to 인터페이스 - 구현 분류는 인터페이스할 수 있어야 한다. 

<br>

위 두 개의 문장대로 구현된 프로그램이라면 이미 리스코프 치환 원칙을 잘 지키고 있는 것이다. 하지만 위 문장대로 구현되지 않은 코드가 존재할 수 있는데 바로 상속이 조직도나 계층도 형태로 구축된 경우다.

<br>

아버지를 상위 클래스(기반 타입)로 하는 딸이라는 하위 클래스(서브 타입)가 있다고 하자. 바로 전형적인 계층도 형태이며, 객체 지향의 상속을 잘못 적용한 예다. 
```java
아버지 춘향이 = new 딸();
```

춘향이는 아버지형 객체 참조 변수이기에 아버지 객체가 가진 행위(메서드)를 할 수 있어야 하는데 춘향이에게 아버지의 어떤 역할을 시킬 수 있을까??

<br>

다음은 동물 클래스와 이를 상속(확장)하는 펭귄 클래스다. 이것은 분류도 형태다. 

```java
동물 뽀로로 = new 펭귄();
```
논리적인 흠이 없다. 펭귄 한 마리가 태어나 뽀로로라고 이름을 짓고 동물의 행위(메서드)를 하게 하는데 전혀 이상함이 없다. 아버지 - 딸 구조(계층도/조직도)는 리스코프 치환 원칙을 위배하고 있는 것이며, 동물 - 펭귄 구조(분류도)는 리스코프 치환 원칙을 만족하는 것이다. 

<br>

**"하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는 데 문제가 없어야 한다."**

<br>

***정리**
<br>
결국 리스코프 치환 원칙은 객체 지향의 상속이라는 특성을 올바르게 활용하면 자연스럽게 얻게 되는 것이다. 

<br>

## ISP - 인터페이스 분리 원칙
"클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안 된다." - 로버트 C.마틴

<br>

인터페이스 분할 원칙(ISP)과 단일 책임 원칙(SRP)은 같은 문제에 대한 두 가지 다른 해결책이라고 볼 수 있다. 프로젝트 요구사항과 설계자의 취향에 따라 단일 책임 원칙이나 인터페이스 분할 원칙 중 하나를 선택해서 설계할 수 있다. 하지만 특별한 경우가 아니라면 단일 책임 원칙을 적용하는 것이 더 좋은 해결책이다.

<br>

인터페이스 분할 원칙을 이야기할 때 항상 함께 등장하는 원칙 중 하나로 인터페이스 최소주의 원칙이라는 것이 있다. 인터페이스를 통해 메서드를 외부에 제공할 때는 최소한의 메서드만 제공하라는 것이다. ex) 남자친구 인터페이스에 사격하기() 메서드를 제공할 필요도 없고 제공해서도 안된다는 것이다. 

<br>

상위 클래스는 풍성할수록 좋고, 인터페이스는 작을수록 좋다.

<br>

### - 빈약한 상위 클래스를 이용하는 경우

<br>

|사람|학생 extends 사람|군인 extends 사람|
|-|-|-|
|이름|생일<br>주민등록번호<br>학번|생일<br>주민등록번호<br>군번
|먹다()|자다()<br>소개하다()<br>공부하다()|자다()<br>소개하다()<br>훈련하다()

<br>

```java
package poorSuperClass;

import java.util.Date;

public class Driver {

    public static void main(String[] args) {
        사람 김학생 = new 학생("김학생", new Date(2000, 01, 01), "20000101-1234567", "20190001");
        사람 이군인 = new 군인("이군인", new Date(1998, 12, 31), "19981231-1234567", "19-12345678");

        System.out.println(김학생.이름);
        System.out.println(이군인.이름);

        // System.out.println(김학생.생일); // 사용불가
        // System.out.println(이군인.생일); // 사용불가

        System.out.println(((학생) 김학생).생일); // 캐스팅 필요
        System.out.println(((군인) 이군인).생일); // 캐스팅 필요

        // System.out.println(김학생.주민등록번호); // 사용불가
        // System.out.println(이군인.주민등록번호); // 사용불가

        System.out.println(((학생) 김학생).주민등록번호); // 캐스팅 필요
        System.out.println(((군인) 이군인).주민등록번호); // 캐스팅 필요

        김학생.먹다();
        이군인.먹다();

        // 김학생.자다(); // 사용불가
        // 이군인.자다(); // 사용불가

        ((학생) 김학생).자다(); // 캐스팅 필요
        ((군인) 이군인).자다(); // 캐스팅 필요

        // 김학생.소개하다(); // 사용불가
        // 이군인.소개하다(); // 사용불가

        ((학생) 김학생).소개하다(); // 캐스팅 필요
        ((군인) 이군인).소개하다(); // 캐스팅 필요

        ((학생) 김학생).공부하다(); // 캐스팅 필요
        ((군인) 이군인).훈련하다(); // 캐스팅 필요

    }
}

```

빈약한 상위 클래스를 이용하는 경우 여기저기 형변환이 발생하면서 상속의 혜택을 제대로 누리지 못하고 있다. 물론 김학생 객체 참조 변수를 사람형이 아닌 학생형으로, 이군인 객체 참조 변수를 군인형으로 선언하고 사용하면 되겠지만 그럼 굳이 상속 구조를 만들 필요도 없다. 상위 클래스형의 참조 변수를 이용해야 상속의 가장 큰 혜택을 볼 수 있다. 

<br>

### - 풍성한 상위 클래스를 이용하는 경우

<br>

|사람|학생 extends 사람|군인 extends 사람|
|-|-|-|
|이름<br>생일<br>주민등록번호|학번|군번
|먹다()<br>자다()<br>소개하다()|공부하다()|훈련하다()

<br>

```java
package richSuperClass;

import java.util.Date;

public class Driver {

    public static void main(String[] args) {
        사람 김학생 = new 학생("김학생", new Date(2000, 01, 01), "20000101-1234567", "20190001");
        사람 이군인 = new 군인("이군인", new Date(1998, 12, 31), "19981231-1234567", "19-12345678");
    }

    System.out.println(김학생.이름);
    System.out.println(이군인.이름);

    System.out.println(김학생.생일);
    System.out.println(이군인.생일);

    System.out.println(김학생.주민등록번호);
    System.out.println(이군인.주민등록번호);

    // System.out.println(김학생.학번); // 사용불가
    // System.out.println(이군인.군번); // 사용불가

    System.out.println(((학생) 김학생).학번); // 캐스팅 필요
    System.out.println(((군인) 이군인).군번); // 캐스팅 필요

    김학생.먹다();
    이군인.먹다();

    김학생.자다();
    이군인.자다();

    김학생.소개하다();
    이군인.소개하다();

    // 김학생.공부하다(); // 사용불가
    // 이군인.훈련하다(); // 사용불가

    ((학생) 김학생).공부하다(); // 캐스팅 필요
    ((군인) 이군인).훈련하다(); // 캐스팅 필요

}

```

<br>

## DIP - 의존 역전 원칙
"고차원 모듈은 저차원 모듈에 의존하면 안된다. 이 두 모듈 모두 다른 추상화된 것에 의존해야 한다."
<br><br>
"추상화된 것은 구체적인 것에 의존하면 안된다. 구체적인 것이 추상화된 것에 의존해야 한다."
<br><br>
"자주 변경되는 구체(Concrete)" 클래스에 의존하지 마라"
<br><br>
-로버트 C.마틴

<br><br>

### - 의존 역전 원칙 적용 전(자주 변경되는 구체 클래스에 의존)
![NO DIP IMAGE](https://user-images.githubusercontent.com/72378121/129129494-2dd90c54-db43-4ed2-9e30-5695f31d8c95.jpeg)

자동차는 한 번 사면 몇년은 타야 하는데 스노우타이어는 계절이 바뀌면 일반 타이어로 교체해야 한다. 이런 경우 스노우타이어를 일반타이어로 교체할 때 자동차는 그 영향에 노출돼 있음을 알 수 있다. 즉, 자동차 자신보다 더 자주 변하는 스노우타이어에 의존하고 있는 것이 문제다. 

<br>

### - 의존 역전 원칙 적용 후 
![YES DIP IMAGE](https://user-images.githubusercontent.com/72378121/129129656-7a5e71ed-65a3-4fe1-9f96-a54947e1161a.jpeg)

자동차가 구체적인 타이어들(스노우타이어, 일반타이어, 광폭타이어)이 아닌 추상화된 타이어 인터페이스에만 의존하게 함으로써 스노우타이어에서 일반타이어로, 또는 다른 구체적인 타이어로 변경돼도 자동차는 이제 그 영향을 받지 않는 형태로 구성된다. 
<br><br>
자동차는 자신보다 변하기 쉬운 스노우타이어에 의존하던 관계를 중간에 추상화된 타이어 인터페이스를 추가해 두고 의존 관계를 역전시키고 있다. 이처럼 자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향받지 않게 하는 것이 의존 역전 원칙이다. 

<br>

***결론**
<br>
상위 클래스일수록, 인터페이스일수록, 추상 클래스일수록 변하지 않을 가능성이 높기에 하위 클래스나 구체 클래스가 아닌 상위 클래스, 인터페이스, 추상 클래스를 통해 의존하라는 것이 바로 의존 역전 원칙이다. 
